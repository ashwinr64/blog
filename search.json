[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I write about tech, finance and all things I learn"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Hello World!\n\n\n\n\n\n\nblogging\n\n\n\n\n\n\n\n\n\nOct 1, 2022\n\n\nChristian Wittmann\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2022-10-01-hello-world/index.html",
    "href": "posts/2022-10-01-hello-world/index.html",
    "title": "Hello World!",
    "section": "",
    "text": "Hello World!"
  },
  {
    "objectID": "market_data.html",
    "href": "market_data.html",
    "title": "RedisTimeseriesManager Example: Market Data(OHLCV)",
    "section": "",
    "text": "In this example, we are going to maintain the data of some financial markets. We have chosen the cryptocurrency and irx for our example. Each market contain several instruments that we refer to them as symbols and we collect OHLCV(open, high, low, close, volume) data for each symbol.\nThe raw data is directly collected from the market with the resolution of seconds and we insert them in raw timeframe. Then we compress(downsample) the data to timeframes of 1m, 1h and 1d. As the names open, high, low, close, volume implies, we use the FIRST aggregator for open, MAX for high, MIN for low, LAST for close and the SUM aggregator for volume to compress the data and build the appropriate timeframes of data.\nWe also want to keep 1m data for just one week, 1h for one month and respectively 1d data for a year. In this Example, we use the classifier 1(c1) to identify the market(here cryptocurrency or irx) and the classifier 2(c2) for the symbols.\n\nimport time, datetime, random\nfrom pytz import timezone\n\nfrom redis_timeseries_manager import RedisTimeseriesManager\n\nsettings = {\n    'host': 'localhost',\n    'port': 6379,\n    'db': 13,\n    'password': None,\n}\n\nclass MarketData(RedisTimeseriesManager):\n    _name = 'markets'\n    _lines = ['open', 'high', 'low', 'close', 'volume']\n    _timeframes = {\n        'raw': {'retention_secs': 60*60*24*4}, # retention 4 days\n        '1m': {'retention_secs': 60*60*24*7, 'bucket_size_secs': 60}, # retention 7 day; timeframe 60 secs\n        '1h': {'retention_secs': 60*60*24*30, 'bucket_size_secs': 60*60}, # retention 1 month; timeframe 3600 secs\n        '1d': {'retention_secs': 60*60*24*365, 'bucket_size_secs': 60*60*24}, # retention 1 year; timeframe 86400 secs\n    }\n\n    #compaction rules\n    def _create_rule(self, c1:str, c2:str, line:str, timeframe_name:str, timeframe_specs:str, source_key:str, dest_key:str):\n        if line == 'open':\n            aggregation_type = 'first'\n        elif line == 'close':\n            aggregation_type = 'last'\n        elif line == 'high':\n            aggregation_type = 'max'\n        elif line == 'low':\n            aggregation_type = 'min'\n        elif line == 'volume':\n            aggregation_type = 'sum'\n        else:\n            return\n        bucket_size_secs = timeframe_specs['bucket_size_secs']\n        self._set_rule(source_key, dest_key, aggregation_type, bucket_size_secs)\n    \n    @staticmethod\n    def print_data(data):\n        for ts, open, high, low, close, volume in data:\n            print(f\"{datetime.datetime.fromtimestamp(ts, tz=timezone('UTC')):%Y-%m-%d %H:%M:%S}, open: {open}, high: {high}, low: {low}, close: {close}, volume: {volume}\")\n\n\nmd = MarketData(**settings)\n\nIn this example, we donâ€™t create timeseries explicitly using the create() method. Instead, the series are created automatically while inserting data by turning on the create_inplace option.\n\ncrypto_btc = []\ncrypto_eth = []\nirx_usd = []\n# generating random data from 2020-01-01 to 2020-03-01; raw(seconds) resolution\nfor ts in range(1577836800, 1583020800, 60):\n    btc = (random.randint(20000, 21000), random.randint(10000000, 20000000))\n    eth = (random.randint(1500, 1600), random.randint(1000000, 2000000))\n    usd = (random.randint(30000, 35000), random.randint(1000, 2000))\n    crypto_btc.append([ts, btc[0], btc[0], btc[0], btc[0], btc[1]])\n    crypto_eth.append([ts, eth[0], eth[0], eth[0], eth[0], eth[1]])\n    irx_usd.append([ts, usd[0], usd[0], usd[0], usd[0], usd[1]])\n\n# adding data\nprint(md.insert(\n    data=crypto_btc,\n    c1='crypto',\n    c2='btc',\n    create_inplace=True,\n)[1], 'records inserted for crypto:btc:raw')\n\nprint(md.insert(\n    data=crypto_eth,\n    c1='crypto',\n    c2='eth',\n    create_inplace=True,\n)[1], 'records inserted for crypto:eth:raw')\n\nprint(md.insert(\n    data=irx_usd,\n    c1='irx',\n    c2='usd',\n    create_inplace=True,\n)[1], 'records inserted for irx:usd:raw')\n\n432000 records inserted for crypto:btc:raw\n432000 records inserted for crypto:eth:raw\n432000 records inserted for irx:usd:raw\n\n\nTaking a look at btc data in raw timeframe, printing the first 10 records. As you can see, data older than retention period is deleted:\n\ndata = md.read(\n    c1='crypto',\n    c2='btc',\n    timeframe='raw',\n)\nmd.print_data(data[1][:10])\n\n2020-02-25 23:59:00, open: 20313.0, high: 20313.0, low: 20313.0, close: 20313.0, volume: 17434667.0\n2020-02-26 00:00:00, open: 20059.0, high: 20059.0, low: 20059.0, close: 20059.0, volume: 17449903.0\n2020-02-26 00:01:00, open: 20440.0, high: 20440.0, low: 20440.0, close: 20440.0, volume: 19759404.0\n2020-02-26 00:02:00, open: 20535.0, high: 20535.0, low: 20535.0, close: 20535.0, volume: 17050135.0\n2020-02-26 00:03:00, open: 20352.0, high: 20352.0, low: 20352.0, close: 20352.0, volume: 12414002.0\n2020-02-26 00:04:00, open: 20908.0, high: 20908.0, low: 20908.0, close: 20908.0, volume: 16608832.0\n2020-02-26 00:05:00, open: 20640.0, high: 20640.0, low: 20640.0, close: 20640.0, volume: 11738248.0\n2020-02-26 00:06:00, open: 20730.0, high: 20730.0, low: 20730.0, close: 20730.0, volume: 12529980.0\n2020-02-26 00:07:00, open: 20010.0, high: 20010.0, low: 20010.0, close: 20010.0, volume: 13072315.0\n2020-02-26 00:08:00, open: 20329.0, high: 20329.0, low: 20329.0, close: 20329.0, volume: 18525989.0\n\n\nMaking sure data is properly downsampled for the 1h timeframe of btc. Just looking at last 10 records:\n\ndata = md.read_last_n_records(\n    c1='crypto',\n    c2='btc',\n    timeframe='1h',\n    minimum_timestamp=0,\n    n=10,\n)\nmd.print_data(data[2])\n\n2020-02-29 13:00:00, open: 20735.0, high: 20950.0, low: 20017.0, close: 20092.0, volume: 889585609.0\n2020-02-29 14:00:00, open: 20255.0, high: 20994.0, low: 20008.0, close: 20159.0, volume: 907397638.0\n2020-02-29 15:00:00, open: 20639.0, high: 20981.0, low: 20040.0, close: 20210.0, volume: 914919852.0\n2020-02-29 16:00:00, open: 20881.0, high: 20988.0, low: 20000.0, close: 20754.0, volume: 873184318.0\n2020-02-29 17:00:00, open: 20925.0, high: 20980.0, low: 20029.0, close: 20957.0, volume: 885453408.0\n2020-02-29 18:00:00, open: 20435.0, high: 20945.0, low: 20003.0, close: 20057.0, volume: 884260516.0\n2020-02-29 19:00:00, open: 20809.0, high: 20984.0, low: 20015.0, close: 20750.0, volume: 901757513.0\n2020-02-29 20:00:00, open: 20873.0, high: 20996.0, low: 20006.0, close: 20202.0, volume: 902661579.0\n2020-02-29 21:00:00, open: 20520.0, high: 20960.0, low: 20001.0, close: 20714.0, volume: 930434483.0\n2020-02-29 22:00:00, open: 20536.0, high: 20985.0, low: 20069.0, close: 20364.0, volume: 958616971.0\n\n\nAnd finally the 1d timeframe for btc:\n\ndata = md.read_last_n_records(\n    c1='crypto',\n    c2='btc',\n    timeframe='1d',\n    minimum_timestamp=0,\n    n=10,\n)\nmd.print_data(data[2])\n\n2020-02-19 00:00:00, open: 20731.0, high: 21000.0, low: 20000.0, close: 20115.0, volume: 21330534906.0\n2020-02-20 00:00:00, open: 20334.0, high: 21000.0, low: 20001.0, close: 20459.0, volume: 21515641617.0\n2020-02-21 00:00:00, open: 20029.0, high: 21000.0, low: 20000.0, close: 20905.0, volume: 21711650439.0\n2020-02-22 00:00:00, open: 20411.0, high: 21000.0, low: 20000.0, close: 20928.0, volume: 21446299869.0\n2020-02-23 00:00:00, open: 20085.0, high: 21000.0, low: 20001.0, close: 20492.0, volume: 21767227948.0\n2020-02-24 00:00:00, open: 20113.0, high: 21000.0, low: 20000.0, close: 20524.0, volume: 21589199638.0\n2020-02-25 00:00:00, open: 20005.0, high: 21000.0, low: 20000.0, close: 20313.0, volume: 21593589792.0\n2020-02-26 00:00:00, open: 20059.0, high: 21000.0, low: 20000.0, close: 20308.0, volume: 21449804558.0\n2020-02-27 00:00:00, open: 20248.0, high: 21000.0, low: 20000.0, close: 20430.0, volume: 21506463397.0\n2020-02-28 00:00:00, open: 20202.0, high: 21000.0, low: 20000.0, close: 20158.0, volume: 21501350295.0\n\n\nWhat about Ethereum?\n\ndata = md.read_last_n_records(\n    c1='crypto',\n    c2='eth',\n    timeframe='1d',\n    minimum_timestamp=0,\n    n=10,\n)\nmd.print_data(data[2])\n\n2020-02-19 00:00:00, open: 1596.0, high: 1600.0, low: 1500.0, close: 1556.0, volume: 2143999543.0\n2020-02-20 00:00:00, open: 1554.0, high: 1600.0, low: 1500.0, close: 1586.0, volume: 2161415271.0\n2020-02-21 00:00:00, open: 1506.0, high: 1600.0, low: 1500.0, close: 1531.0, volume: 2149807932.0\n2020-02-22 00:00:00, open: 1579.0, high: 1600.0, low: 1500.0, close: 1578.0, volume: 2154955516.0\n2020-02-23 00:00:00, open: 1585.0, high: 1600.0, low: 1500.0, close: 1581.0, volume: 2162673381.0\n2020-02-24 00:00:00, open: 1514.0, high: 1600.0, low: 1500.0, close: 1555.0, volume: 2153614376.0\n2020-02-25 00:00:00, open: 1566.0, high: 1600.0, low: 1500.0, close: 1507.0, volume: 2155428171.0\n2020-02-26 00:00:00, open: 1568.0, high: 1600.0, low: 1500.0, close: 1580.0, volume: 2160880310.0\n2020-02-27 00:00:00, open: 1545.0, high: 1600.0, low: 1500.0, close: 1598.0, volume: 2150496148.0\n2020-02-28 00:00:00, open: 1576.0, high: 1600.0, low: 1500.0, close: 1540.0, volume: 2168125300.0\n\n\nWe also had a market called irx, whats going on with it?\n\ndata = md.read_last_n_records(\n    c1='irx',\n    c2='usd',\n    timeframe='1d',\n    minimum_timestamp=0,\n    n=10,\n)\nmd.print_data(data[2])\n\n2020-02-19 00:00:00, open: 32384.0, high: 35000.0, low: 30000.0, close: 31769.0, volume: 2153204.0\n2020-02-20 00:00:00, open: 30362.0, high: 34997.0, low: 30002.0, close: 32887.0, volume: 2165782.0\n2020-02-21 00:00:00, open: 34322.0, high: 35000.0, low: 30014.0, close: 32140.0, volume: 2172368.0\n2020-02-22 00:00:00, open: 34090.0, high: 34996.0, low: 30006.0, close: 31156.0, volume: 2142013.0\n2020-02-23 00:00:00, open: 31106.0, high: 34995.0, low: 30006.0, close: 31497.0, volume: 2155531.0\n2020-02-24 00:00:00, open: 33332.0, high: 35000.0, low: 30000.0, close: 32006.0, volume: 2158651.0\n2020-02-25 00:00:00, open: 31023.0, high: 35000.0, low: 30008.0, close: 31511.0, volume: 2177522.0\n2020-02-26 00:00:00, open: 30033.0, high: 34992.0, low: 30000.0, close: 31871.0, volume: 2147087.0\n2020-02-27 00:00:00, open: 34626.0, high: 34998.0, low: 30001.0, close: 30956.0, volume: 2175925.0\n2020-02-28 00:00:00, open: 32097.0, high: 34997.0, low: 30004.0, close: 34060.0, volume: 2175474.0"
  },
  {
    "objectID": "market_data.html#other-commands",
    "href": "market_data.html#other-commands",
    "title": "RedisTimeseriesManager Example: Market Data(OHLCV)",
    "section": "Other Commands",
    "text": "Other Commands\nIn the background, several keys are created in the redis db. To inspect the list of keys, run the following command:\n\nmd.query_index(return_key_names=True)[1]\n\n['markets:crypto:btc:1d:close',\n 'markets:crypto:btc:1d:high',\n 'markets:crypto:btc:1d:low',\n 'markets:crypto:btc:1d:open',\n 'markets:crypto:btc:1d:volume',\n 'markets:crypto:btc:1h:close',\n 'markets:crypto:btc:1h:high',\n 'markets:crypto:btc:1h:low',\n 'markets:crypto:btc:1h:open',\n 'markets:crypto:btc:1h:volume',\n 'markets:crypto:btc:1m:close',\n 'markets:crypto:btc:1m:high',\n 'markets:crypto:btc:1m:low',\n 'markets:crypto:btc:1m:open',\n 'markets:crypto:btc:1m:volume',\n 'markets:crypto:btc:raw:close',\n 'markets:crypto:btc:raw:high',\n 'markets:crypto:btc:raw:low',\n 'markets:crypto:btc:raw:open',\n 'markets:crypto:btc:raw:volume',\n 'markets:crypto:eth:1d:close',\n 'markets:crypto:eth:1d:high',\n 'markets:crypto:eth:1d:low',\n 'markets:crypto:eth:1d:open',\n 'markets:crypto:eth:1d:volume',\n 'markets:crypto:eth:1h:close',\n 'markets:crypto:eth:1h:high',\n 'markets:crypto:eth:1h:low',\n 'markets:crypto:eth:1h:open',\n 'markets:crypto:eth:1h:volume',\n 'markets:crypto:eth:1m:close',\n 'markets:crypto:eth:1m:high',\n 'markets:crypto:eth:1m:low',\n 'markets:crypto:eth:1m:open',\n 'markets:crypto:eth:1m:volume',\n 'markets:crypto:eth:raw:close',\n 'markets:crypto:eth:raw:high',\n 'markets:crypto:eth:raw:low',\n 'markets:crypto:eth:raw:open',\n 'markets:crypto:eth:raw:volume',\n 'markets:irx:usd:1d:close',\n 'markets:irx:usd:1d:high',\n 'markets:irx:usd:1d:low',\n 'markets:irx:usd:1d:open',\n 'markets:irx:usd:1d:volume',\n 'markets:irx:usd:1h:close',\n 'markets:irx:usd:1h:high',\n 'markets:irx:usd:1h:low',\n 'markets:irx:usd:1h:open',\n 'markets:irx:usd:1h:volume',\n 'markets:irx:usd:1m:close',\n 'markets:irx:usd:1m:high',\n 'markets:irx:usd:1m:low',\n 'markets:irx:usd:1m:open',\n 'markets:irx:usd:1m:volume',\n 'markets:irx:usd:raw:close',\n 'markets:irx:usd:raw:high',\n 'markets:irx:usd:raw:low',\n 'markets:irx:usd:raw:open',\n 'markets:irx:usd:raw:volume']\n\n\nYou can inspect the info of each key by running the stats command as shown in the next cell.\n\nNote that each key have lablels properly filled with respective data(c1, c2, ...), so you can take advantage of redis multi-timeseries commands like TS.MRANGE\n\n\nmd.stats('crypto', 'btc', 'raw', 'close').__dict__\n\n{'rules': [[b'markets:crypto:btc:1m:close', 60000, b'LAST'],\n  [b'markets:crypto:btc:1h:close', 3600000, b'LAST'],\n  [b'markets:crypto:btc:1d:close', 86400000, b'LAST']],\n 'source_key': None,\n 'chunk_count': 4,\n 'memory_usage': 17013,\n 'total_samples': 5761,\n 'labels': {'tl': 'markets',\n  'c1': 'crypto',\n  'c2': 'btc',\n  'line': 'close',\n  'timeframe': 'raw'},\n 'retention_msecs': 345600000,\n 'lastTimeStamp': 1583020740000,\n 'first_time_stamp': 1582675140000,\n 'chunk_size': 4096,\n 'duplicate_policy': 'last'}"
  }
]